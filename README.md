# CSharpCodeStyle

## Оформление
### Поля и свойства
`private` - именуется в стиле lowerCamelCase с нижним подчеркиванием перед названием:_samplePrivateVariableName

`protected`/`public` - именуется в стиле UpperCamelCase:SampleField

`const` поля - именуются в стиле UpperCamelCase

### Переменные
Любые локальные переменные и переменные - параметры метода именуются в стиле lowerCamelCase

### Классы и структуры
Любые классы и структуры именуются в стиле UpperCamelCase

### Методы
Все методы именуются в стиле UpperCamelCase.

Если метод - обработчик событий, то его необходимо именовать в стиле EventName_EventHandler или, если необходима конкретика - `ObjectNameEventName_EventHandler`

### Делегаты
Все делегаты именуются в стиле UpperCamelCase. Для имени используются стиль DelegateSampleName, где Delegate обязательная приставка.

### События
Все события именуются в стиле UpperCamelCase. Для имени используется стиль EventSampleName, где Event - обязательная приставка

### Интерфейсы
Все интерфейсы именуются в стиле UppercamelCase с приставкой I перед именем: ISampleInterface

### Отступы модули
Необходимо оставлять одну пустую строку после:

1. Имени класса
2. Декларации функции
3. Декларации любого модуля

Если в строке больше 140 символов, то необходимо выполнить перенос на новую строку (если есть Resharper, то это делается автоматически, в VisualStudio необходимо настраивать вручную)

Любой модуль нужно открывать на одной строке с именем идентификатора (K&R style):
```C#
sampleSelector {

}
```
При объявлении переменных и свойств необходимо отделять их от других элементов класса 3мя пустыми строками, если они логически связаны между собой.

### Структура оформления класса (структуры)
При описании класса иерархия элементов по методам доступа имеет вид:

`public`
`protected`
`private`

При описании полей и свойств сначала описываются поля.

При описании свойств и полей сперва описываются readonlyполя или свойства.

### Структура оформления:

1. Делегаты
2. Const поля
3. События
4. Поля и свойства
5. Конструкторы
6. Методы
7. `static`-методы

Желательно оборачивать каждый стэк элементов в #region

Реализация любого интерфейса должна заключаться в #region с именем InterfaceName Implementation

Использование структур
Вы можете использовать структуры только в трех случаях:

Когда метод принимает больше 5-ти аргументов. В таком случае необходимо обернуть параметры метода структурой и соответствующим образом изменить сигнатуру метода

Когда сущность не должна быть ссылочным типом. В таком случае в структуре должны храниться толькоValue Typeпеременные.

Когда необходимо оптимизировать участок кода - доступ к структуре осуществляется быстрее чем доступ к классу, т.к. структура размещается в стэке.

## Принцип использования Static
Класс может быть помечен static, если он содержит ТОЛЬКО методы.

ВНИМАНИЕ!!!! Если вам нужен Singleton, то это не значит, что вы должны объявлять класс как static

Метод должен быть static, если он является фабричным или возвращает одноименный с классом тип.

Поле или свойство описывается staticТОЛЬКО при реализации паттерна Singleton. И ВОЗМОЖНО если вам нужно кэшировать информацию.

Чтобы описать поле или свойство как public static необходимо иметь очень хорошее обоснование или бессмертие.

## Комментарии
Для любого метода или поля или свойства необходимо писать документирующий комментарий:

`/// <summary>...</summary>`

Если метод выбрасывает исключения - их необходимо заносить внутрь документирующего комментария:

`/// <throws>...</throws>`

Внутри метода или свойства все комментарии обычные.

Лучше получить ReSharper - он быстро генерит нужную разметку для документирующих комментариев

Или же можно использовать GhostDock - он автоматически генерирует полную разметку, подставляет комментарии наследников и вообще делает много полезностей

## `Equals` и `HashCode`
Если вы переопределяете метод Equalsу объектов, то вам нужно переопределить и метод HashCode. Т.к. некоторые коллекции могут использовать комбинацию этих методов.

При этом, при переопределении GetHashCodeнеобходимо помнить о том, что этот метод должен возвращать одинаковое значения для одного и того же объекта при каждом вызове. Причем,у двух одинаковых объектов всегда равны хэш-коды, но равенство хэш-кодов не говорит о равенстве объектов.

Эти методы должны сразу, не дожидаясь итерации тестирования покрываться unit-тестами.

### `Equals`
Паттерн для переопределения метода Equalsу объекта типа Sample:
```C#
public override bool Equals (object obj) {

  if(this == null) {
    return false;
  }

  if(object == null) {
    return false;
  }

  if(this.GetHashCode != obj.GetHashCode) {
    return false;
  }

  var temp = obj as Sample;

  if(temp == null) {
    return false;
  }

  // ручная проверка, например полей. Рекомендуется делать в таком виде:

  var equalsFlag =this.Field1 == temp.Field1 &&this.Field2 == temp.Field2….

  return equalsFlag;
}
```
### `GetHashCode`
Метод GetHashCode должен возвращать одинаковые значения в течении всей жизни объекта. То есть, он должен полагаться только на НЕИЗМЕНЯЕМЫЕ члены класса.

Паттерн хэш функции: `this.unchangedField1 ^ this.unchangedField2 ^ …..`

^ - это не возведение в степень! это исключающее или! В C# он прям так и оформляется!

## Использование атрибутов
### `[Obsolete]`
Если во время разработки вы решили, что какой-то из ранее написанных вами методов либо плохо работает, либо он просто не удовлетворяет требованиям, либо просто он вам не нравится, то его не нужно удалять (если только там не полный бред). Помечайте его атрибутом [Obsolete]- так он будет помечен как неиспользуемый и опасный. Для удобства последующего рефакторинга его можно закоментить, но, советую, поставить решарпер - он начнет ругаться на использование подобного метода.

### `[NotNull]`
Используется для аргументов метода. Должен использоваться ВСЕГДА, если параметры передаваемые в метод не должны быть nullпо смыслу.

Данная аннотация поставляется вместе с ReSharper.

### `[CanBeNull]`
Используется для аргументов метода. Должен быть использован ВСЕГДА, если параметр может быть `null`.

Данная аннотация поставляется вместе в ReSharper
